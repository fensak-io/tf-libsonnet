// Meta-argument constructor functions. Refer to the meta-arguments tab on
// https://developer.hashicorp.com/terraform/language for more information.
//
// This can be used as arguments to the `_meta` parameter for any resource
// or data source constructor generated by libgenerator.

local h = import './helpers.libsonnet';

// newMeta will generate an object that can be mixed into any resource or data
// source to set the Terraform meta arguments.
local newMeta(count=null, depends_on=null, for_each=null, provider=null, lifecycle=null) =
  local maybeCount =
    if count != null then
      { count: count }
    else
      {};

  local maybeDependsOn =
    if depends_on != null then
      { depends_on: depends_on }
    else
      {};

  local maybeForEach =
    if for_each != null then
      { for_each: for_each }
    else
      {};

  local maybeProvider =
    if provider != null then
      { provider: provider }
    else
      {};

  local maybeLifecycle =
    if lifecycle != null then
      { lifecycle: lifecycle }
    else
      {};

  maybeCount
  + maybeDependsOn
  + maybeForEach
  + maybeProvider
  + maybeLifecycle;


// newModuleMeta will generate an object that can be mixed into any module call to set the Terraform meta arguments.
local newModuleMeta(count=null, depends_on=null, for_each=null, providers=null) =
  local maybeCount =
    if count != null then
      { count: count }
    else
      {};

  local maybeDependsOn =
    if depends_on != null then
      { depends_on: depends_on }
    else
      {};

  local maybeForEach =
    if for_each != null then
      { for_each: for_each }
    else
      {};

  local maybeProviders =
    if providers != null then
      if std.isObject(providers) then
        { providers: providers }
      else
        error 'providers meta argument must be a map'
    else
      {};

  maybeCount
  + maybeDependsOn
  + maybeForEach
  + maybeProviders;


// newLifecycle will generate a new lifecycle block. Note that unlike the other functions, this includes type checking
// due to the Terraform requirement that the lifecycle block only supports literal values only. As such, it is easier to
// do a type check on the args since there is no possibility to use complex Terraform expressions (which will reduce to
// a string type in jsonnet).
local newLifecycle(
  create_before_destroy=null,
  prevent_destroy=null,
  ignore_changes=null,
  replace_triggered_by=null,
  precondition=null,
  postcondition=null,
      ) =
  local maybeCreateBeforeDestroy =
    if create_before_destroy != null then
      if std.isBoolean(create_before_destroy) then
        { create_before_destroy: create_before_destroy }
      else
        error 'lifecycle meta argument attr create_before_destroy must be a boolean'
    else
      {};

  local maybePreventDestroy =
    if prevent_destroy != null then
      if std.isBoolean(prevent_destroy) then
        { prevent_destroy: prevent_destroy }
      else
        error 'lifecycle meta argument attr prevent_destroy must be a boolean'
    else
      {};

  local maybeIgnoreChanges =
    if ignore_changes != null then
      if h.isStringArray(ignore_changes) then
        { ignore_changes: ignore_changes }
      else
        error 'lifecycle meta argument attr ignore_changes must be a string array'
    else
      {};

  local maybeReplaceTriggeredBy =
    if replace_triggered_by != null then
      if h.isStringArray(replace_triggered_by) then
        { replace_triggered_by: replace_triggered_by }
      else
        error 'lifecycle meta argument attr replace_triggered_by must be a string array'
    else
      {};

  local maybePrecondition =
    if precondition != null then
      if std.isArray(precondition) then
        { precondition: precondition }
      else
        error 'lifecycle meta argument attr precondition must be an array of condition blocks'
    else
      {};

  local maybePostcondition =
    if postcondition != null then
      if std.isArray(postcondition) then
        { postcondition: postcondition }
      else
        error 'lifecycle meta argument attr postcondition must be an array of condition blocks'
    else
      {};

  maybeCreateBeforeDestroy
  + maybePreventDestroy
  + maybeIgnoreChanges
  + maybeReplaceTriggeredBy
  + maybePrecondition
  + maybePostcondition;


// newCondition will generate a new condition block that can be used as part of precondition or postcondition in the
// lifecycle block.
local newCondition(condition, error_message) =
  {
    condition: condition,
    error_message: error_message,
  };


// root object
{
  meta:: {
    new:: newMeta,
    newForModule:: newModuleMeta,
    lifecycle:: {
      new:: newLifecycle,
      condition:: {
        new:: newCondition,
      },
    },
  },
}
